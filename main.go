package main

import (
	"fmt"
	"os"
	"time"
	"log"
	"context"
	"strings"
	"errors"

	"github.com/joho/godotenv"
	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"
	"github.com/slack-go/slack/socketmode"
)


func main() {
	godotenv.Load(".env")

	token := os.Getenv("SLACK_AUTH_TOKEN")
	appToken := os.Getenv("SLACK_APP_TOKEN")

	// Create new client
	client := slack.New(token, slack.OptionDebug(true), slack.OptionAppLevelToken(appToken))

	// go-slack comes with a SocketMode package that we need to use that accepts a Slack client and outputs a Socket mode client instead
	socketClient := socketmode.New(
		client,
		socketmode.OptionDebug(true),
		// Option to set a custom logger
		socketmode.OptionLog(log.New(os.Stdout, "socketmode: ", log.Lshortfile|log.LstdFlags)),
	)

	// Make a context that can be used to cancel our goroutine
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func(ctx context.Context, client *slack.Client, socketClient *socketmode.Client) {
		// For loop that selects either the context cancellation or the incoming event
		for {
			select {
			case <-ctx.Done():
				log.Println("Shutting down socketmode listener")
				return
			case event := <-socketClient.Events:
				// New Event, let's typeswitch the event
				// TODO add use cases/switches for other event types
				switch event.Type {
					// handle EventAPI events
					case socketmode.EventTypeEventsAPI:
						// The Event sent on the channel is not the same as the EventAPI events so we need to type cast it
						eventsAPIEvent, ok := event.Data.(slackevents.EventsAPIEvent)
						if !ok {
							log.Printf("Could not type cast the event to the EventsAPIEvent: %v\n", event)
							continue
						}
						// Send an ACK to the slack server
						socketClient.Ack(*event.Request)

						// Now we have an Events API event, but it can still be one of a bunch of types, so we need further type switching
						err := handleEventMessage(eventsAPIEvent, client)
						if err != nil {
							// TODO put real error handling here
							log.Fatal(err)
						}
					// Handle slash commands
					case socketmode.EventTypeSlashCommand:
						command, ok := event.Data.(slack.SlashCommand)
						if !ok {
							log.Printf("Could not typecast the message to a SlashCommand: %v\n", command)
							continue
						}
						// Ack the request
						socketClient.Ack(*event.Request)
						err := handleSlashCommand(command, client)
						if err != nil {
							log.Fatal(err)
						}

				}
			}
		}
	}(ctx, client, socketClient)


	socketClient.Run()
}


// handleEventMessage will take an event, do some type switching, and handle it properly based on the type of event it is
func handleEventMessage(event slackevents.EventsAPIEvent, client *slack.Client) error {
	switch event.Type {
	case slackevents.CallbackEvent:

		// Inside that callbackevent is another event type, but we don't know which one...
		innerEvent := event.InnerEvent

		// Type switch on that innerevent's data to see if it's an AppMentionEvent
		switch ev := innerEvent.Data.(type) {
		case *slackevents.AppMentionEvent:
			err := handleAppMentionEvent(ev, client)
			if err != nil {
				return err
			}
		}

	default:
		return(errors.New("Unsupported event type."))
	}
	return nil
}


// handleSlashCommand will take any slash command and route it to the proper handler function (or else return an error)
func handleSlashCommand(command slack.SlashCommand, client *slack.Client) error {
	switch command.Command {
		case "/greet":
			return handleGreetCommand(command, client)
	}

	return nil
}

// handleGreetCommand implements a simple greeting response
func handleGreetCommand(command slack.SlashCommand, client *slack.Client) error {
	// Input is found in the text field
	// Our response is an attachment, again.
	attachment := slack.Attachment{}
	attachment.Fields = []slack.AttachmentField{
		{
			Title: "Date",
			Value: time.Now().String(),
		}, {
			Title: "Initializer",
			Value: command.UserName,
		},
	}

	attachment.Text = fmt.Sprintf("Hello %s", command.Text)
	attachment.Color = "#4af030"

	// Send it (channel is command.ChannelID)
	_, _, err := client.PostMessage(command.ChannelID, slack.MsgOptionAttachments(attachment))
	if err != nil {
		return fmt.Errorf("Failed to post message: %w", err)
	}
	return nil
}


// handleAppMentionEvent responds to the event generated by user @mentioning the bot
func handleAppMentionEvent(event *slackevents.AppMentionEvent, client *slack.Client) error {
	// Get username based on the user ID of whoever mentioned the bot
	user, err := client.GetUserInfo(event.User)
	if err != nil {
		return err
	}

	// Did the user say "hello?"
	text := strings.ToLower(event.Text)

	// Create the response attachment
	attachment := slack.Attachment{}
	attachment.Fields = []slack.AttachmentField{
		{
			Title: "Date",
			Value: time.Now().String(),
		}, {
			Title: "Initializer",
			Value: user.Name,
		},
	}
	if strings.Contains(text, "hello") {
		// greeting
		attachment.Text = fmt.Sprintf("Hello %s", user.Name)
		attachment.Pretext = "Greetings"
		attachment.Color = "4af030"
	} else {
		// send a message to the user
		attachment.Text = fmt.Sprintf("How can I help you %s?", user.Name)
		attachment.Pretext = "How can I be of service"
		attachment.Color = "#3d3d3d"
	}

	// Send it! (channel name is available in the event message)
	_, _, err = client.PostMessage(event.Channel, slack.MsgOptionAttachments(attachment))
	if err != nil {
		return fmt.Errorf("Failed to post message: %w", err)
	}

	return nil
}


func sendSlackMessageAsAttachment(message string, channelID string, client socketmode.Client) {
	// We're going to send an "attachment" message
	attachment := slack.Attachment{
		Pretext: "tutorialinuxBot Message",
		Text: message,
		Color: "#36a64f",
		// Fields are optional extra data
		Fields: []slack.AttachmentField{
			{
				Title: "Date",
				Value: time.Now().String(),
			},
		},
	}

	// PostMessage does what it says on the tin
	// First returned value is just the channelID, so we ignore it
	_, timestamp, err := client.PostMessage(
		channelID,
		// uncomment the item below to add a extra Header to the message, try it out :)
		// slack.MsgOptionText("New message from bot", false),
		slack.MsgOptionAttachments(attachment),
	)

	if err != nil {
		panic(err)
	}

	fmt.Printf("Message sent at %s", timestamp)
}
